---
phase: 04-gmb-match-rate-optimization
plan: 04-01
type: execute
---

<objective>
Add location biasing and additional search variations to Google Places API queries to improve GMB match rates from current 25% baseline.

Purpose: Increase successful GMB matches by providing more context (geographic bias) and trying additional query formats (phone variations, partial addresses) that may match businesses with incomplete or inconsistent data.
Output: Enhanced googlePlaces.ts with locationBias parameter and additional fallback search strategies
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/googlePlaces.ts

**Current state:**
- 10 fallback search strategies already implemented (lines 194-344)
- Current match rate: ~25% (from batch enrichments)
- Uses simple textQuery parameter only - no locationBias, includedType, or other advanced parameters
- Phone search uses exact format from input (line 208)
- Address search combines all components into single query string (lines 217-233)

**Google Places API (New) capabilities discovered:**
- `locationBias` parameter: Bias results to geographic region (circle or rectangle) without strict boundaries
- Circle format: `{ circle: { center: { latitude, longitude }, radius: meters } }`
- Phone numbers can be searched in multiple formats: international (+1), formatted (###) ###-####, unformatted ##########
- Partial address queries work: street number + street name without city can find businesses

**Constraining decisions:**
- Preserve monolithic architecture (no refactoring)
- Maintain existing rate limiting (1 req/sec) and retry logic
- Keep fuzzy name matching logic (lines 62-116)
- Maintain match score validation (calculateMatchScore method lines 541-695)

**API documentation sources:**
- [Text Search (New) API Reference](https://developers.google.com/maps/documentation/places/web-service/reference/rest/v1/places/searchText)
- [Place Types](https://developers.google.com/maps/documentation/places/web-service/place-types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add locationBias parameter to searchForPlace() using geocoding</name>
  <files>src/services/googlePlaces.ts</files>
  <action>
Modify the searchForPlace() method (line 346) to accept optional lat/lng parameters and add locationBias to API request when available.

1. Update method signature:
```typescript
private async searchForPlace(query: string, latitude?: number, longitude?: number): Promise<string | null>
```

2. When lat/lng provided, add locationBias to request body (inside retryWithBackoff callback, line 350):
```typescript
const requestBody: any = {
  textQuery: query,
  pageSize: 1,
};

// Add location bias if coordinates provided (50km radius)
if (latitude !== undefined && longitude !== undefined) {
  requestBody.locationBias = {
    circle: {
      center: { latitude, longitude },
      radius: 50000, // 50km radius - wide enough to catch suburbs but focused
    },
  };
}
```

3. Update all searchForPlace() calls in findPlace() method to pass coordinates when available:
   - For city/state queries: Use city center coordinates (we'll add geocoding helper)
   - For zip code queries: Use zip center coordinates
   - For other queries: Pass undefined (no bias)

4. Create simple geocoding helper using state/city lookup (no external API needed):
```typescript
/**
 * Get approximate coordinates for city/state for location biasing
 * Returns null if location not recognized
 */
function getCityCoordinates(city: string, state: string): { latitude: number; longitude: number } | null {
  // Map major US cities to coordinates (top 100 cities cover most queries)
  // Format: "city, ST" -> { lat, lng }
  const cityCoords: Record<string, { latitude: number; longitude: number }> = {
    // Major cities (add top 50-100 US cities)
    'new york, ny': { latitude: 40.7128, longitude: -74.0060 },
    'los angeles, ca': { latitude: 34.0522, longitude: -118.2437 },
    'chicago, il': { latitude: 41.8781, longitude: -87.6298 },
    'houston, tx': { latitude: 29.7604, longitude: -95.3698 },
    'phoenix, az': { latitude: 33.4484, longitude: -112.0740 },
    // Add more cities as needed (start with ~20-30 major metros)
  };

  const key = `${city.toLowerCase()}, ${state.toLowerCase()}`;
  return cityCoords[key] || null;
}
```

5. Apply locationBias to Strategy 2 (business + full address), Strategy 3 (business + city/state), Strategy 4 (business + state), Strategy 8 (abbreviated name + city/state)

WHY no external geocoding API: Avoid adding another external dependency and rate limit. Static city coordinates are sufficient for location biasing (doesn't need exact precision).
  </action>
  <verify>
Grep for locationBias usage: `grep -n "locationBias" src/services/googlePlaces.ts`
Should show requestBody.locationBias assignment and usage in multiple search strategies.
  </verify>
  <done>searchForPlace() accepts lat/lng parameters, adds locationBias to request when coordinates provided, getCityCoordinates() helper exists, findPlace() strategies 2-4 and 8 pass coordinates</done>
</task>

<task type="auto">
  <name>Task 2: Add phone number format variations to Strategy 1</name>
  <files>src/services/googlePlaces.ts</files>
  <action>
Expand Strategy 1 (phone search, lines 205-213) to try multiple phone formats.

Current implementation tries phone as-is. Add format variations:

```typescript
// Strategy 1: Try phone number in multiple formats (most accurate identifier)
if (phone) {
  const phoneDigits = phone.replace(/\D/g, ''); // Extract just digits

  // Variation 1a: Phone as provided (current behavior)
  const placeId = await this.searchForPlace(phone);
  if (placeId) {
    logger.info('Found place by phone (original format)', { phone, placeId });
    return placeId;
  }

  // Variation 1b: Try with +1 country code if not present
  if (phoneDigits.length === 10) {
    await this.rateLimit();
    const phoneWithCountry = `+1${phoneDigits}`;
    const placeId = await this.searchForPlace(phoneWithCountry);
    if (placeId) {
      logger.info('Found place by phone (+1 format)', { phone: phoneWithCountry, placeId });
      return placeId;
    }
  }

  // Variation 1c: Try formatted (###) ###-####
  if (phoneDigits.length === 10) {
    await this.rateLimit();
    const formatted = `(${phoneDigits.slice(0, 3)}) ${phoneDigits.slice(3, 6)}-${phoneDigits.slice(6)}`;
    const placeId = await this.searchForPlace(formatted);
    if (placeId) {
      logger.info('Found place by phone (formatted)', { phone: formatted, placeId });
      return placeId;
    }
  }

  // Variation 1d: Try unformatted 10 digits
  if (phoneDigits.length >= 10) {
    await this.rateLimit();
    const unformatted = phoneDigits.slice(-10); // Last 10 digits (removes country code if present)
    const placeId = await this.searchForPlace(unformatted);
    if (placeId) {
      logger.info('Found place by phone (digits only)', { phone: unformatted, placeId });
      return placeId;
    }
  }
}
```

WHY multiple formats: Google Places may have phone stored in different format than input. Trying variations increases match probability without being overly broad.
  </action>
  <verify>
Read lines 205-250 of googlePlaces.ts - should show 4 phone format variations with rate limiting between each.
  </verify>
  <done>Strategy 1 tries 4 phone formats: original, +1 prefix, formatted (###) ###-####, and 10-digit unformatted</done>
</task>

<task type="auto">
  <name>Task 3: Add partial address and street-only search variations</name>
  <files>src/services/googlePlaces.ts</files>
  <action>
Add two new search strategies between Strategy 2 and Strategy 3 for partial address matching.

Insert after Strategy 2 (business + full address, line 223):

```typescript
// Strategy 2b: Try business name with street address only (no city)
// Some businesses are well-known on their street and city adds noise
if (address) {
  await this.rateLimit();
  const placeId = await this.searchForPlace(`${businessName} ${address}`);
  if (placeId) {
    logger.info('Found place by business name + street only', { businessName, address });
    return placeId;
  }
}

// Strategy 2c: Try business name with zip + street (zip is more specific than city)
if (address && zip) {
  await this.rateLimit();
  const placeId = await this.searchForPlace(`${businessName} ${address} ${zip}`);
  if (placeId) {
    logger.info('Found place by business name + street + zip', { businessName, address, zip });
    return placeId;
  }
}
```

WHY partial addresses: Full addresses sometimes fail to match due to slight differences in formatting (e.g., "Street" vs "St"). Street-only or street+zip queries can be more flexible while still specific enough to avoid false matches.
  </action>
  <verify>
Count search strategies: `grep -n "Strategy [0-9]" src/services/googlePlaces.ts | wc -l`
Should increase from 10 to 12 strategies total.
  </verify>
  <done>Strategies 2b and 2c added for partial address searches (street-only and street+zip), total search strategies increased to 12</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] Grep shows locationBias parameter usage in searchForPlace
- [ ] Phone search strategy shows 4 format variations
- [ ] Total search strategies increased from 10 to 12
- [ ] getCityCoordinates() helper function exists with major city mappings
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript compilation errors
- locationBias added to relevant search strategies
- Phone search tries 4 format variations
- Two new partial address strategies added
- Total of 12 search strategies (up from 10)
- Code maintains existing patterns and rate limiting
</success_criteria>

<output>
After completion, create `.planning/phases/04-gmb-match-rate-optimization/04-01-SUMMARY.md`:

---
phase: 04-gmb-match-rate-optimization
plan: 04-01
subsystem: enrichment-services
requires:
  - 03-01
provides:
  - Enhanced GMB search with location biasing
  - Additional search variation patterns
affects:
  - 04-02
tags:
  - data-quality
  - gmb-matching
  - search-optimization
key-decisions:
  - Used static city coordinate mapping instead of external geocoding API
  - Added locationBias with 50km radius (wide enough for suburbs, focused enough to help)
  - Tried 4 phone format variations without being overly broad
  - Added partial address strategies (street-only, street+zip)
key-files:
  - src/services/googlePlaces.ts
tech-stack:
  added: []
  patterns:
    - Location biasing with static geocoding
    - Phone format variation pattern
    - Partial address fallback pattern
patterns-established:
  - getCityCoordinates() helper for major US cities
  - locationBias parameter added to searchForPlace()
  - 12 total search strategies (was 10)
next-phase-readiness:
  - Ready for 04-02: Match rate measurement and analysis
---

# Phase 4 Plan 1: GMB Search Enhancements Summary

**Added location biasing and search variations to improve GMB match rates**

## Accomplishments

- Added locationBias parameter to Google Places API requests with 50km radius
- Created getCityCoordinates() helper with major US city mappings
- Expanded phone search to try 4 format variations (+1 prefix, formatted, digits-only)
- Added 2 new partial address strategies (street-only, street+zip)
- Increased total search strategies from 10 to 12

## Files Created/Modified

- [src/services/googlePlaces.ts](src/services/googlePlaces.ts) - Enhanced search strategies and added location biasing

## Decisions Made

- Used static city coordinates instead of external geocoding API to avoid new dependency
- Set locationBias radius to 50km (balances coverage vs precision)
- Phone variations limited to 4 formats (enough coverage without being too broad)
- Partial address strategies focus on street+zip and street-only (highest value variations)

## Issues Encountered

None

## Verification

- User verified TypeScript compilation succeeds
- User confirmed 12 search strategies present
- User verified locationBias and phone variations implemented

## Next Step

Ready for 04-02: Measure match rate improvements and analyze results
</output>
